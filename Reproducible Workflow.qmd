---
title: "Reproducible Workflow"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

Notes on creating reproducible analytical pipelines from here:

https://raps-with-r.dev/intro.html

DRY: Don't Repeat Yourself; WIT: Write IT down.

# Functional Programming

"Functional programming is a paradigm that relies exclusively on the evaluation of functions to achieve the desired result."

The `<<-` operator saves a variable defined within a function to the global environment. (But generally you don't want to be doing this in a function.)

"A referentially transparent function is a function that does not use any variable that is not also one of its inputs...Defining and using such functions must be avoided at all costs because these functions are unpredictable."

From Wikipedia:

"In computer programming, a pure function is a function that has the following properties: \[1\] the function return values are identical for identical arguments (no variation with local static variables, non-local variables, mutable reference arguments or input streams), and \[2\] the function has no side effects (no mutation of local static variables, non-local variables, mutable reference arguments or input/output streams)."

Try to use pure functions.

## Writing Functions

Functions can take other functions as arguments:

```{r}
h <- function(number, f){
  f(number)
}

h(4, sqrt)

# If the input function might have additional inputs
# use the ellipsis '...'

h <- function(number, f, ...){
  f(number, ...)
}

h(c(1, 2, NA, 3), mean, na.rm = TRUE)
```

A function can output another function. These are 'function factories'.

```{r}
# This example turns warnings into errors

strictly <- function(f){
  function(...){
    tryCatch({
      f(...)
    },
    warning = function(warning)stop("Can't do that chief"))
  }
}

strictly(sqrt)(4)
strictly(sqrt)(-4)
```

You can make a function argument optional by setting its value to NULL.

Recursive functions in R are very slow.

It's better to have functions return lists of information, rather than printing things out to the console.

Loops are slow - instead try to lapply or map a function to a list.

```{r}
data(iris)
library(ggplot2)

iris_nest <- iris |>
  dplyr::group_nest(Species) 

iris_nest |>
  dplyr::mutate(nrows = purrr::map(data, nrow))

make_plot <- function(a, b){
  ggplot(data = a) +
    geom_point(
      aes(
        x = Sepal.Length,
        y = Petal.Length
      ),
      alpha = .5
    ) + 
    labs(
      title = b
    )
}

iris_nest <- iris_nest |>
  dplyr::mutate(
    plots = map2(
      .x = data,
      .y = Species,
      .f = make_plot
    )
  )

iris_nest$plots
```

## R Markdown

You can write code that will return sections of an R Markdown (or Quarto) document.

```{r}
create_table <- function(dataset, var){
  table(dataset[var]) |>
    knitr::kable()
}

return_section <- function(dataset, var){
  a <- knitr::knit_expand(text = c("## Frequency table for variable: {{variable}}",   
                                   create_table(dataset, var)),
                          variable = var)
  cat(a, sep = "\n")
}

invisible(lapply(colnames(mtcars), return_section, dataset = mtcars))

```
