---
title: "Basic R"
format: html
editor: source
editor_options: 
  chunk_output_type: console
---

alt-shift-k -> R Studio shortcuts

# Efficiency

* A golden rule in R programming is to access the underlying C/Fortran routines as quickly as possible; the fewer functions calls required to achieve this, the better.

* Pre-allocate objects rather than growing them (e.g. by a for-loop).

* Using 1:length(x) can lead to hard-to-find bugs (e.g. in for-loops) when x has length zero. Instead use seq_along(x) or seq_len(length(x)). 

## I/O

* If possible, keep the names of local files downloaded from the internet or copied onto your computer unchanged. This will help you trace the provenance of the data in the future.

* R’s native file format is .Rds. These files can be imported and exported using readRDS() and saveRDS() for fast and space efficient data storage.

* Use import() from the rio package to efficiently import data from a wide range of formats, avoiding the hassle of loading format-specific libraries.

* Use the readr or data.table equivalents of read.table() to efficiently import large text files.

* Use file.size() and object.size() to keep track of the size of files and R objects and take action if they get too big.

Example of getting data from a webpage:

```{r}
url = "https://www.monetdb.org/sites/default/files/voc_tsvs.zip"
download.file(url, "voc_tsvs.zip") # download file
unzip("voc_tsvs.zip", exdir = "data") # unzip files
file.remove("voc_tsvs.zip") # tidy up by removing the zip file

url = "https://vincentarelbundock.github.io/Rdatasets/csv/datasets/co2.csv"
download.file(url, "extdata/co2.csv")
df_co2 = read_csv("extdata/co2.csv")
```

# Useful Functions

```{r}
# Update R Stuff

# check and install the latest R version
installr::updateR()
installr::install.rtools()

# update installed CRAN packages
update.packages() 
```

```{r}
ls() # List of objects in the environment

Sys.info() # System and User Info

Sys.Date()
Sys.time()
```

# Names & Values

Copy-on-modify behavior:

```{r}
x <- 1:3 # Create x
y <- x # have y bound to same underlying value as x
y[3] <- 4
y
x
```

When y is modified, the underlying value is not modified. Rather, a new (altered) value is created and y is bound to that new value.

Using tracemem to see when an object gets copied:

```{r}
x <- c(1, 2, 3)
cat(tracemem(x), "\n") # Shows object's current address

y <- x
y[[3]] <- 4L

untracemem(x) # turns off memory tracing
```

If you modify `y` again, it won't get copied. That's because the new object now only has a single name bound to it, so R applies modify-in-place optimisation.

Lists don't store values themselves, but references to those values. So you get similar behaviors.

```{r}
x <- list(1, 2, 3)
y <- x
y[[1]] <- 4

x
y
```

### Object Size

```{r}
x <- 1:10
lobstr::obj_size(x)

y <- 1:1e5
lobstr::obj_size(y)

# Same size, since R just stores the first and last numbers

lobstr::obj_size(c('A', 'B', 'C'))
```

### Modify-in-Place

Modifying an object usually creates a copy, except when it's an object with a single binding or an 'environment'.

### Garbage Collector

The 'garbage collector' removes objects that are no longer used (are no longer bound to any objects) and requests more memory from the operating system when needed.

| R uses a **tracing** GC. This means it traces every object that's reachable from the global environment, and all objects that are, in turn, reachable from those objects (i.e. the references in lists and environments are searched recursively).

```{r}
gcinfo(TRUE) # shows when the garbage collector runs
```

# Data Structures

1-Dimensional:

-   Vectors (Homogeneous)
-   Lists (Heterogeneous)

2-Dimensional:

-   Matrix (Homogeneous)
-   Data Frame (Heterogeneous)

N-Dimensional:

-   Array (Homogeneous)

## Vectors

Two types: atomic vectors and lists

Three properties:

```{r}

X <- c('a', 'b', 1)

str(X) # Show structure of object
typeof(X) # Show type of object
length(X) # How many elements it contains
attributes(X) # Show additional metadata

# Don't use is.atomic(), is.numeric(), is.vector()
```

### Atomic Vectors

Four common types: double, integer, logical, character

Less common types: complex, raw

```{r}
# 'L' suffix specifies integers
X <- c(6, 2, 5, 9)
typeof(X)
X <- c(6L, 2L, 5L, 9L)
typeof(X)

# Atomic vectors are always flat, so nested vectors get leveled
X <- c(1, c(2, c(3)))
X

int_var <- c(1L, 6L, 10L)
typeof(int_var)
is.integer(int_var)

dbl_var <- c(1, 2.5, 4.5)
typeof(dbl_var)
is.double(dbl_var)

# is.numeric returns TRUE for either double or integer
```

Coercion: to make all elements of an atomic vector of the same type, elements will be coerced to the most flexible type. In order of flexibility: logical, integer, double, and character.

```{r}
# Useful for dealing with logical vectors for mathematical operations
X <- c(0, 0, 0, 1, 1, 1, 1, 1)
mean(X)

# Can explicitly coerce with as.character(), as.double(), as.integer(), or as.logical()
```

#### Missing Values

Technically there are four missing values, one for each of the atomic types: `NA` (logical), `NA_integer_` (integer), `NA_real_` (double), and `NA_character_` (character). This distinction is usually unimportant because `NA` will be automatically coerced to the correct type when needed.

### Lists

The elements of a list can be of any type, including other lists.

```{r}
X <- list(1, 2, 3, T, F, 'Hello', 3.14159)

str(X)
typeof(X)
length(X)
attributes(X)

# Unlike atomic vectors, lists can be recursive
is.recursive(X)
X <- list(1, list(2, 3), list(4, 5, list(6)))
str(X)
X

# c() combines several lists into one
X <- list(1, 2, 3)
Y <- list('a', 'b', 'c')
c(X, Y)

# To check if list
is.list(X)
# To coerce to list
as.list(c(1, 2))

unlist(X) # takes a list an produces vector with its atomic components
unlist(c(X, Y))
```

## Attributes

All objects can have additional arbitrary attributes

```{r}
X <- 1:10
attr(X, 'Name') <- "Eric's Vector"
str(X)

structure(X, Name = "Eric's New Vector")
# Lets you change attributes

# Ways of specifying names
c('a' = 1, 'b' = 3, 'c' = 24) # Option 1
X <- 1:3
names(X) <- c('a', 'b', 'c') # Option 2
X <- setNames(1:3, c('A', 'B', 'C')) # Option 3

# Use names() to get and modify names
names(X)
names(X) <- c('a', 'b')

X <- unname(X) # remove names
```

Most attributes are lost when modifying a vector. Names and dimension are the only attributes routinely preserved through operations.

### Class

> Having a class attribute turns an object into an **S3 object**, which means it will behave differently from a regular vector when passed to a **generic** function. Every S3 object is built on top of a base type, and often stores additional information in other attributes.

Four important S3 vectors in R:

-   Factors

-   Dates

-   Date-Times

-   Durations

### Factors

Factors are built on top of integer vectors using two attributes: the `class`, "factor", which makes them behave differently from regular integer vectors, and the `levels`, which defines the set of allowed values.

As a general rule, if your variable has an inherent order, e.g. small vs large, or you have a fixed set of categories, then you should consider using a factor.

```{r}
X <- factor(c('brown', 'brown', 'red', 'red', 'blue', 'green'))

str(X) # Factor w/4 levels
typeof(X) # Note it has integer type
levels(X)
attributes(X)
class(X)

# You can't use values that are not in the factor's levels
X[7] <- 'black'
X

unclass(X)
```

### Dates

Built on top of double vectors. They have a 'date' attribute and no other attributes.

```{r}
today <- Sys.Date()

typeof(today)
attributes(today)

# The value of the underlying double is n-days since 1970-01-01
date <- as.Date("1970-02-01")
unclass(date)
```

### Date-Times

Two ways of storing date-times: POSIXct & POSIXlt "POSIX" is short for Portable Operating System Interface 'ct' = 'calendar time' 'lt' = 'local time'

POSIXct vectors are built on top of double vectors, where the value represents the number of seconds since 1970-01-01. Takes a time zone attribute.

```{r}
now <- as.POSIXct('2023-04-05 4:23', tz = 'EST')
typeof(now) # underlying vector is a double
class(now)
attributes(now)
```

### Durations

Represent the difference between dates or date-times. Built on top of doubles and have a 'units' attribute.

```{r}
one_week_1 <- as.difftime(1, units = "weeks")
one_week_1

typeof(one_week_1)
attributes(one_week_1)

one_week_2 <- as.difftime(7, units = "days")
one_week_2

typeof(one_week_2)
attributes(one_week_2)
```

### Dimension

```{r}
x <- matrix(1:6, nrow = 2, ncol = 3)
x

y <- array(1:12, c(2, 3, 2))
y

# You can also modify an object in place by setting dim()
z <- 1:6
dim(z) <- c(3, 2)
```

## Data Frames

A data frame is a named list of vectors with attributes for (column) names, row.names, and its class, "data.frame". The length of each vector must be the same (unlike regular lists).

```{r}
df1 <- data.frame(x = 1:3, y = letters[1:3])
typeof(df1)
class(df1)
attributes(df1)

# Contrast with a tibble
df2 <- tibble::as_tibble(df1)
typeof(df2)
class(df2) # tibbles have a longer class vector than dfs
attributes(df2)
```

You create a dataframe by supplying name-vector pairs to data.frame(). A key difference with tibbles is that character vectors are by default converted to factors for data.frame(). Additionally, non-syntactic names are converted to syntactic names.

```{r}
df3 <- data.frame(
  `1` = 1:3,
  `2 `= c('Hello', 'Hi', 'Howdy')
)
```

While every element of a data frame (or tibble) must have the same length, both data.frame() and tibble() will recycle shorter inputs. However, while data frames automatically recycle columns that are an integer multiple of the longest column, tibbles will only recycle vectors of length one.

Generally, using row names for dataframes is frowned upon.

```{r}
# To get rid of rownames:
df4 <- data.frame(
  age = c(35, 27, 18),
  hair = c("blond", "brown", "black"),
  row.names = c("Bob", "Susan", "Sam")
)

tibble::rownames_to_column(df4)
```

Important tibble/df difference for subsetting:

-   When you subset columns with df\[, vars\], you will get a vector if vars selects one variable, otherwise you'll get a data frame. This is a frequent source of bugs when using \[ in a function, unless you always remember to use df\[, vars, drop = FALSE\].

-   When you attempt to extract a single column with df$x and there is no column x, a data frame will instead select any variable that starts with x. If no variable starts with x, df$x will return NULL. This makes it easy to select the wrong variable or to select a variable that doesn't exist.

Tibbles tweak these behaviours so that a \[ always returns a tibble, and a \$ doesn't do partial matching and warns if it can't find a variable

## NULL

NULL is a unique type that has length 0 and can't have any attributes.

```{r}
typeof(NULL)
length(NULL)

x <- NULL
attr(x, "y") <- 1

is.null(x)
```

Use this to represent an empty vector of arbitrary type or an absent vector.

# Subsetting

## ...for Atomic Vectors

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
x[c(3, 1)]
x[order(x)]

# Duplicate indices will duplicate values
x[c(1, 1)]

# Real numbers are silently truncated to integers
x[c(2.1, 2.9)]

# Negative integers exclude elements
x[c(-1, -2)]
# Note that you can't mix positive & neg integers

# Logical vectors filter for when the value is TRUE
x[x > 2.5]

# for x[y], if y < x then y will be recycled
y <- c(TRUE, FALSE)
x[y]

x[0] # returns 0 length vector
x[] # returns original vector
```

Subsetting a list works like subsetting an atomic vector. \[\] will return another list while \[\[\]\] will return the value itself.

## Matrices and Arrays

```{r}
x <- matrix(1:9, nrow = 3)
colnames(x) <- c("A", "B", "C")
x[1:2, ]
```

Most common subsetting method is to use multiple 1-D vectors

```{r}
x[c(TRUE, FALSE, TRUE), c("B", "A")]

x[2, 3]

x[2,] # blank vector for a dimension returns all values
class(x[2,])
is.matrix(x[2,])
# The [] operator simplifies the result to the lowest possible dimensionality.
```

You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value, and each column corresponds to a dimension in the array. This means that you can use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3D array, and so on.

## Dataframes

Data frames have the characteristics of both lists and matrices:

-   When subsetting with a single index, they behave like lists and index the columns, so df\[1:2\] selects the first two columns.

-   When subsetting with two indices, they behave like matrices, so df\[1:3, \] selects the first three rows (and all the columns

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2, ]
```

# Control

## Choices

Switch statements

```{r}
# Replace this
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}

# With this
x_option <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid `x` value")
  )
}

# The last component of a switch() should always throw an error, otherwise unmatched inputs will invisibly return NULL
```

## Loops

```{r}
# Basic for loop
for (i in 1:10) {
  if (i < 3) 
    next # move to next iteration

  print(i)
  
  if (i >= 5)
    break # end loop
}
```

Common for-loop problems:

First, if you're generating data, make sure to preallocate the output container. Otherwise the loop will be very slow.

```{r}
# Example with output container
means <- c(1, 50, 20)
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
```

Second, watch out for iterating over 1:length(x) if x has length 0, which will throw errors. Use seq_along instead.

```{r}
means <- c()
out <- vector("list", length(means))
seq_along(means)

for (i in seq_along(means)) {
  out[[i]] <- rnorm(10, means[[i]])
} # No errors
```

Finally, you might encounter problems when iterating over S3 vectors, as loops typically strip the attributes.

```{r}
xs <- as.Date(c("2020-01-01", "2010-01-01"))
for (x in xs) {
  print(x)
}

# Instead do this
for (i in seq_along(xs)) {
  print(xs[[i]])
}
```


# Functions



Raise fatal errors with `stop()`.

Functions to use within your functions: stop(), try(), tryCatch(), warning(), message(), cat() -> for communicating with the user
